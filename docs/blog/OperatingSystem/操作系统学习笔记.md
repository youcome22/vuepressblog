# 操作系统

## 1.1.1 操作系统的概念 (定义)

​	操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。



## 1.1.2 操作系统的功能和目标

### 1）作为系统资源的管理者

- 处理机管理
- 存储器管理
- 文件管理
- 设备管理

目标：安全、高效



### 2）作为用户和计算机硬件之间的接口

①命令接口：允许用户直接使用

- 联机命令接口（交互式命令接口），如Windows DOS
- 脱机命令接口（批处理命令接口），.bat 批处理文件

②程序接口：允许用户通过程序间接使用

​	在程序中调用 xxx.dll 即可实现创建窗口等功能。该调用过程即为系统调用，只能通过用户程序间接调用。

![image-20220509095914347](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509095914347.png)

③GU:现代操作系统中最流行的图形用户接口

​	用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数

​	目标：方便用户使用



### 3）作为最接近硬件的层次

​	需要提供的功能和目标：实现对硬件机器的拓展

​	没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器

​	通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机

​	



## 1.1.3 操作系统的特征

![image-20220509100849225](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509100849225.png)



### 1）并发

指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
常考易混概念一一并行：指两个或多个事件在同一时刻同时发生。

操作系统的并发性指计算机系统中同时存在着多个运行着的程序。



### 2）共享

即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

![image-20220509101425666](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509101425666.png)

所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）



#### 并发与共享的关系

并发性指计算机系统中同时存在着多个运行着的程序。

共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。

- 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义
- 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发



### 3）虚拟

​	虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。

![image-20220509103135598](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509103135598.png)

​	显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。



### 4）异步

​	异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

​	显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。



## 1.1.4 操作系统的发展与分类

### 1）手工操作阶段

​	主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低



### 2）批处理阶段——单道批处理系统

引入脱机输入/输出技术（用磁带完成），并监督程序负责控制作业的输入/输出

​	主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

​	主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待/O完成。资源利用率依然很低。



### 3）批处理阶段——多道批处理系统

​	主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。

​	主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行)



### 4）分时操作系统

​	分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

​	主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

​	主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。



### 5）实时操作系统

​	主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。

​	在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。

![image-20220509104635782](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509104635782.png)



### 6）其它操作系统

​	网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用)

​	分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。

​	个人计算机操作系统：如Windows XP、MacOs,方便个人使用。



## 1.1.5 操作系统运行机制和体系结构

1）“指令”就是处理器(CPU)能识别、执行的最基本命令

![image-20220509105015154](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509105015154.png)



2）两种处理器状态

![image-20220509105210374](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509105210374.png)



3）两种程序

![image-20220509122354846](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509122354846.png)

4）运行机制

![image-20220509122432031](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509122432031.png)



## 1.1.6 操作系统的内核

![image-20220509122650241](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509122650241.png)

内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。
实现操作系统内核功能的那些程序就是内核程序。

- 时钟管理：实现计时功能
- 中断处理：负责实现中断机制
- 原语：是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分，这种程序的运行具有原子性（即运行只能持续性不可中断），原语运行时间较短、调用频繁。



## 1.1.7 操作系统体系结构

大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态

- 优点：高性能
- 缺点：内核代码庞大，结构混乱，难以维护

微内核：只把最基本的功能保留在内核

- 优点：内核功能少，结构清晰，方便维护
- 缺点：需要频繁地在核心态和用户态之间切换，性能低



## 1.1.8 中断和异常

### 1）中断的概念和作用

​	由于计算机程序处理的串行执行机制，导致效率低下、程序堵塞等问题，人们发明了操作系统并引入中断机制，实现了多道程序并发执行。

​	本质：发生中断就意味着需要操作系统介入，开展管理工作

1.当中断发生时，CPU立即进入核心态
2.当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3.对于不同的中断信号，会进行不同的处理

​	发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。



### 2）中断分类

![image-20220509132742654](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509132742654.png)

内中断：信号的来源于CPU内部与当前执行的指令有关

外中断：信号的来源于CPU外部与当前执行的指令无关



### 3）中断的分类02（主要是对内中断的分类）

![image-20220509133028867](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220509133028867.png)



### 4）外中断处理过程

①每条指令执行结束后，CPU检查是否有外部中断信号

②若有外部中断信号，则需要保护被中断进程的CPU环境

③根据中断信号类型转入相应的中断处理程序

④恢复原进程的CPU环境并退出中断，返回原进程继续往下执行



## 1.1.8 系统调用

### 1）基本概述

​	“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。

​	应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

![image-20221011135157696](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011135157696.png)

​	系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行。



### 2）系统调用与库函数的区别

![image-20221011135332059](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011135332059.png)

- 系统调用是操作系统向上层提供的接口
- 有的库函数是对系统调用的进一步封装
- 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用



### 3）系统调用背后的过程

传递系统调用参数 → 执行陷入指令（用户态）→ 执行系统调用相应服务程序（核心态）→ 返回用户程序

注意：

1.陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态

2.发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行

3.陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令



## 2.1.1 进程的定义、组成、组织方式、特征

### 1）进程的定义

程序：就是一个指令序列

早期的计算机（只支持单道程序）

引入多道程序技术之后：

​	为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念PCB、程序段、数据段三部分构成了进程实体（进程映像

​	程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程。例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。

注意：PCB是进程存在的唯一标志！

从不同的角度，进程可以有不同的定义，比较传统典型的定义有：
	1.进程是程序的一次执行过程。
	2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
	3.进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

​	引入进程实体的概念后，可把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。



### 2）进程的组成

![image-20221011163921886](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011163921886.png)

​	进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的D,用于区分不同的进程（类似于身份证号）

​	各种寄存器值：当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句。



![image-20221011164143147](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011164143147.png)

### 3）进程的组织

​	在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

​	注：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题

![image-20221011164259891](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011164259891.png)

#### 进程的组织——链接方式

![image-20221011164448356](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011164448356.png)



#### 进程的组织——索引方式

![image-20221011164523981](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011164523981.png)

### 4）进程的特征

![image-20221011164712415](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011164712415.png)



## 2.1.2 进程的状态与转换

### 1）三种基本状态	

​	进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。

![image-20221011164829032](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011164829032.png)

​	注意：单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态)

​	进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即：万事俱备，只欠CPU



### 2）另外两种状态

![image-20221011165054669](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011165054669.png)



### 3）进程状态的转换

![image-20221011165347706](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221011165347706.png)



## 2.1.3 进程控制

​	进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销己有进程、实现进程状态转换等功能。

​	用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用“关中断指令”和“开中断指令”实现

​	显然，关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令



进程控制相关的原语

- 1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）
  - a.所有的进程控制原语一定都会修改进程状态标志
  - b.剥夺当前运行进程的cPU使用权必然需要保存其运行环境
  - c.某进程开始运行前必然要恢复期运行环境
- 2.将PCB插入合适的队列
- 3.分配/回收资源



进程的创建

![image-20221012101933783](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012101933783.png)

进程的终止

![image-20221012102140347](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012102140347.png)



## 2.1.4 进程通信

​	顾名思义，进程通信就是指进程之间的信息交换。

​	进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

​	为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。

![image-20221012102434149](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012102434149.png)

### 1）共享存储

![image-20221012102615799](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012102615799.png)

​	两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现)。→操作系统只负责提供共享空间和同步互斥工具（如P、V操作）

![image-20221012102707559](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012102707559.png)



### 2）管道传递

![image-20221012102750766](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012102750766.png)

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲因

1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。

2.各进程要互斥地访问管道。

3.数据以字符流的形式写入管道，当管道写满时，写进程的wite()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read0系统调用将被阻塞。

4.如果没写满，就不允许读。如果没读空，就不允许写。

5.数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情



### 3）消息通信

​	进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

![image-20221012103154068](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012103154068.png)



## 2.1.5 线程的概念和多线程模型

### 1）基本概念

​	“线程”可以把线程理解为“轻量级进程”。

​	线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ
视频、文字聊天、传文件)。

​	引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的)。

![image-20221012103751224](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012103751224.png)



### 2）线程的属性

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销较大



### 3）线程的实现方式

![image-20221012104058412](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012104058412.png)

​	用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换)用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

​	在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)可以这样理解，“用户级线程”就是“从用户视角看能看到的线程

![image-20221012104159638](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012104159638.png)

​	内核级线程的管理工作由操作系统内核完成线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。

​	可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。



​	在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将个用户级线程映射到m
个内核级线程上（n>=m)

![image-20221012104406033](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012104406033.png)

重点重点重点：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。



### 4）多线程模型

#### ①多对一模型

​	在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。

![image-20221012104550894](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012104550894.png)

多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行



#### ②一对一模型

​	在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。

![image-20221012104655251](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012104655251.png)

一对一模型：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



#### ③多对多模型

![image-20221012104734470](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012104734470.png)

​	多对多模型：n用户及线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。

​	克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。



## 2.2.1 处理机调度的概念、层次

### 1）调度的基本概念

​	在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。

​	处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程
的并发执行。



### 2）调度的三个层次

### ①高级调度

![image-20221012105222459](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012105222459.png)

​	由于内存空间有限，有时无法将用户提交的作全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

​	高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB),以使它（们）获得竞争处理机的权利。

​	高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB,作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。



### ②中级调度

![image-20221012105423931](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012105423931.png)

​	引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。

​	暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。

​	中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。



### 补充：进程的挂起态与七状态模型

![image-20221012105706164](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012105706164.png)



### ③低级调度

![image-20221012105805145](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012105805145.png)

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。

进程调度的频率很高，一般几十毫秒一次。



### 三层调度的联系和对比

![image-20221012105849964](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012105849964.png)



## 2.2.2 进程调度的时机、切换与过程、方式

### 1）进程调度的时机

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

![image-20221012213933503](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012213933503.png)

![image-20221012213959815](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221012213959815.png)

临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。

临界区：访问临界资源的那段代码。

内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）



### 2）进程调度的方式

​	非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

→ 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

​	剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

→ 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断)。适合于分时操作系统、实时操作系统



### 3）进程的切换与过程

“狭义的进程调度”与“进程切换”的区别：

​	狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

​	广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1.对原来运行进程各种数据的保存
2.对新的进程各种数据的恢复
(如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)

​	注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。



## 2.2.3 调度算法的评价指标

### 1）CPU利用率

![image-20221013093415761](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013093415761.png)

### 2）系统吞吐量

![image-20221013093503936](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013093503936.png)

### 3）周转时间

​	对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。

​	它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就继队列上等待进程调度（低级调度)的时间、进程在CPU上执行的时间、进程等待/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。

![image-20221013093606392](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013093606392.png)

​	对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。

![image-20221013093820076](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013093820076.png)

### 4）等待时间

计算机的用户希望自己的作业尽可能少的等待处理机

等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。

![image-20221013093941173](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013093941173.png)

​	对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

​	对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

### 5）响应时间

​	对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系
统服务、回应。

​	响应时间，指从用户提交请求到首次产生响应所用的时间。



## 2.2.4 调度算法 (1)

### 1）先来先服务（FCFS）

先来先服务调度算法：按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务

![image-20221013100937821](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013100937821.png)

### 2）短作业优先（SJF）

​	最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。

注意几个小细节：

1.如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的

2.很多书上都会说“SF调度算法的平均等待时阀、平均周转时间最少”。严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”

​	或者说“在所有进程都几乎同时到达时，采用SF调度算法的平均等待时间、平均周转时间最少“。

​	如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先，SRNT算法)的平均等待时间、平均周转时间最少”

3.虽然严格来说，SF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS)，SJF依然可以获得较少的平均等待时间、平均周转时间

4.如果选择题中遇到“SF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项

![image-20221013105643214](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013105643214.png)

### 3）高响应比优先（HRRN）

​	高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。

![image-20221013110042862](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013110042862.png)



注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。



## 2.2.5 调度算法 (2)

### 1）时间片轮转调度算法（RR）

​	时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）

​	如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。

​	另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。

![image-20221013113452119](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013113452119.png)

### 2）优先级调度算法

​	非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。

​	抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是会发生抢占。

补充：

就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置，根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。

- 静态优先级：创建进程时确定，之后一直不变。
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。

 通常：

系统进程优先级高于用户进程；前台进程优先级高于后台进程

操作系统更偏好I/O型进程（或称I/O繁忙型进程）

注：与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）

​	I/O设备和CPU可以并行工作。如果优先让/o繁忙型进程优先运行的话，则越有可能让/o设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。

可以从追求公平、提升资源利用率等角度考虑

- 如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级
- 如果某进程占用处理机运行了很长时间，则可适当降低其优先级
- 如果发现一个进程频繁地进行/O操作，则可适当提升其优先级

![image-20221013121703645](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013121703645.png)

### 3）多级反馈队列调度算法

​	设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。

​	新进程到达时先进入第1级队列，按FC「S原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。

​	只有第k级队列为空时，才会为k+1级队头的进程分配时间片被抢占处理机的进程重新放回原队列队尾。

![image-20221013122542925](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013122542925.png)



## 2.3.1 进程同步与排斥

### 1）进程同步

知识点回顾：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。

​	读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。如何解决这种异步问题，就是“进程同步”所讨论的内容。

​	同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。



### 2）进程互斥

​	进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的/O设备)。

​	我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

​	对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

- 进入区
  - 负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”)，以阻止其他进程同时进入临界区
- 临界区（也称”临界段“）
  - 访问临界资源的那段代码
- 退出区
  - 负责解除正在访问临界资源的标志（可理解为“解锁”）
- 剩余区
  - 做其他处理

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：

1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区：

2.忙则等待。当己有进程进入临界区时，其他试图进入临界区的进程必须等待：

3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；

4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。



## 2.3.2 进程互斥的软件实现方法

### 1）单标志法

​	算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予

![image-20221013144536770](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013144536770.png)

单标志法存在的主要问题是：违背“空闲让进”原则。

### 2）双标志先检查法

算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，如“flag[0]=ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[]设为tue,之后开始访问临界区。

![image-20221013144936137](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013144936137.png)

双标志先检查法的主要问题是：违反“忙则等待”原则。

原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。

### 3）双标志后检查法

​	算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。

![image-20221013145209685](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013145209685.png)

​	因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。

### 4）Peterson算法

​	算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。

![image-20221013145503545](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221013145503545.png)

进入区：1.主动争取；2.主动谦让；3.检查对方是否也想使用，且最后一次是不是自己说了“客气话；

​	Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。

Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。



## 2.3.3 进程互斥的硬件实现方法

### 1）中断屏蔽方法

​	利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)

→ 关中断后即不允许当前进程被中断，也必然不会发生进程切换

→ 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区

优点：简单、高效

缺点：不适用于多处理机：只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)

### 2）TestAndSet（TS指令/TSL指令）

简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令

TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑

相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞：适用于多处理机环境

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

### 3）Swap指令（XCHG指令）

有的地方也叫Exchange指令，或简称XCHG指令。逻辑上与TS指令相同

Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞：适用于多处理机环境

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。



## 2.3.4 信号量机制

​	信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。

​	原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。

​	一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal,,括号里的信号量S其实就是函数调用时传入的一个参数。

​	wait、signal原语常简称为P、V操作（来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、signal(s)两个操作分别写为P(S)、V(s)

### 1）整型信号量

用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。

与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作

![image-20221020170920301](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221020170920301.png)

“检查”和“上锁”一气呵成避免了并发、异步导致的问题

存在的问题：不满足“让权等待原则，会发生“忙等”



### 2）记录型信号量

![image-20221020171204544](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221020171204544.png)

​	在考研题目中wait(S)、signal(s)也可以记为P(s)、V(s)，这对原语可用于实现系统资源的“申请”和“释放”。

​	S.value的初值表示系统中某种资源的数目。

​	对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行S.value-,表示资源数减1，当S.value<0时表示该类资源己分配完毕，因此进程应调用block原语进行自我阻塞（当前运行的进程从运行态→阻塞态)，主动放弃处理机，并插入该类资源的等待队列SL中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。

​	对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行S.value+,表示资源数加1，若加1后仍是S.value<=0,表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第个进程（被唤醒进程从阻塞态→就绪态）



## 2.3.5 实现进程互斥、同步、前驱关系

### （1）信号量实现进程互斥

1.分析并发进程的关键活动，划定临界区

2.设置互斥信号量mutex,初值为1

3.在临界区之前执行P(mutex)

4.在临界区之后执行V(mutex)

​	注意：对不同的临界资源需要设置不同的互斥信号量P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。

![image-20221021101055388](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221021101055388.png)



### （2）信号量实现进程同步

用信号量实现进程同步：

1.分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）

2.设置同步信号量S,初始为0

3.在“前操作”之后执行VS)

4.在“后操作”之前执行P(S)

![image-20221021101405955](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221021101405955.png)



### （3）信号量机制实现前驱关系

![image-20221021101902710](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221021101902710.png)

生产者-消费者问题

​	系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）生产者、消费者共享一个初始为空、大小为的缓冲区。

只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。

只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。

缓冲区是临界资源，各进程必须互斥地访问。

![image-20221228123157861](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221228123157861.png)

如何用信号量机制(P、V操作)实现生产者、消费者进程的这些功能呢？

![image-20230218130200140](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230218130200140.png)

























































































